# Data Model: Foundation Phase

**Created**: 2025-10-24  
**Purpose**: Define initial database schema for Foundation Phase example entities

## Overview

The Foundation Phase includes minimal example schema to demonstrate:

- Constitutional audit field requirements (`created_at`, `updated_at`)
- Type-safe database access via Drizzle ORM
- tRPC integration with database queries
- Best practices for future entity design

**Note**: This is NOT the final Cora Finance v2 data model. Future phases (Master Data, Transactional Engine, Budgeting, etc.) will define production entities. This schema exists solely to validate database connectivity and demonstrate patterns.

---

## Example Entity: `system_health`

### Purpose

Demonstrates database connectivity, schema migrations, and Constitutional compliance. Used by health check endpoint to verify database is accessible.

### Schema Definition

```typescript
// /server/db/schema.ts
import { pgTable, serial, text, timestamp, boolean } from 'drizzle-orm/pg-core';

export const systemHealth = pgTable('system_health', {
  id: serial('id').primaryKey(),
  status: text('status').notNull(), // e.g., "healthy", "degraded"
  message: text('message'), // Optional status message
  checkedAt: timestamp('checked_at', {
    withTimezone: true,
    mode: 'date',
  })
    .notNull()
    .defaultNow(),
  archived: boolean('archived').notNull().default(false), // Soft delete (Constitutional)
  createdAt: timestamp('created_at', {
    withTimezone: true,
    mode: 'date',
  })
    .notNull()
    .defaultNow(), // Constitutional requirement
  updatedAt: timestamp('updated_at', {
    withTimezone: true,
    mode: 'date',
  })
    .notNull()
    .defaultNow()
    .$onUpdate(() => new Date()), // Constitutional requirement
});

export type SystemHealth = typeof systemHealth.$inferSelect;
export type NewSystemHealth = typeof systemHealth.$inferInsert;
```

### Fields

| Field        | Type                     | Constraints                      | Purpose                           |
| ------------ | ------------------------ | -------------------------------- | --------------------------------- |
| `id`         | serial                   | PRIMARY KEY                      | Auto-incrementing identifier      |
| `status`     | text                     | NOT NULL                         | Health status indicator           |
| `message`    | text                     | nullable                         | Optional details about status     |
| `checked_at` | timestamp with time zone | NOT NULL, DEFAULT NOW            | When health was checked           |
| `archived`   | boolean                  | NOT NULL, DEFAULT FALSE          | Soft delete flag (Constitutional) |
| `created_at` | timestamp with time zone | NOT NULL, DEFAULT NOW            | Constitutional audit field        |
| `updated_at` | timestamp with time zone | NOT NULL, DEFAULT NOW, ON UPDATE | Constitutional audit field        |

### Indexes

```sql
CREATE INDEX idx_system_health_checked_at ON system_health(checked_at DESC);
CREATE INDEX idx_system_health_archived ON system_health(archived) WHERE archived = false;
```

**Rationale**:

- `checked_at` index for time-series queries (recent health checks)
- Partial index on `archived = false` to optimize active record queries

---

## Constitutional Compliance

### ✅ Principle V: Data Integrity & Precision

**Audit Fields**:

- ✅ `created_at timestamp with time zone`: Records creation time in UTC (ISO 8601)
- ✅ `updated_at timestamp with time zone`: Records last modification in UTC
- ✅ Automatic update trigger via Drizzle `$onUpdate`

**Soft Deletes**:

- ✅ `archived boolean default false`: Soft delete pattern
- Future queries will filter `WHERE archived = false` by default

**Timestamp Format**:

- ✅ `timestamp with time zone`: Stores in UTC, Constitutional requirement
- ✅ Drizzle `mode: 'date'`: Returns JavaScript Date objects (ISO 8601 compatible)

**No Magic Strings**:

- ⚠️ `status` field currently uses text (acceptable for example)
- 🔮 Future: Replace with enum type when status values are finalized

---

## Migration Strategy

### Initial Migration (Generated by Drizzle Kit)

```sql
-- drizzle/0000_initial.sql
CREATE TABLE IF NOT EXISTS "system_health" (
  "id" serial PRIMARY KEY NOT NULL,
  "status" text NOT NULL,
  "message" text,
  "checked_at" timestamp with time zone DEFAULT now() NOT NULL,
  "archived" boolean DEFAULT false NOT NULL,
  "created_at" timestamp with time zone DEFAULT now() NOT NULL,
  "updated_at" timestamp with time zone DEFAULT now() NOT NULL
);

CREATE INDEX IF NOT EXISTS "idx_system_health_checked_at"
  ON "system_health" ("checked_at" DESC);

CREATE INDEX IF NOT EXISTS "idx_system_health_archived"
  ON "system_health" ("archived")
  WHERE "archived" = false;
```

### Running Migrations

```bash
# Generate migration from schema changes
npm run db:generate

# Apply migrations to database
npm run db:migrate

# Open Drizzle Studio to inspect schema
npm run db:studio
```

---

## Future Entity Patterns

When implementing production entities in future phases, follow these patterns:

### Financial Values (Constitutional Requirement)

```typescript
// CORRECT: Store monetary values as integer cents
export const transactions = pgTable('transactions', {
  id: serial('id').primaryKey(),
  amountCents: integer('amount_cents').notNull(), // €123.45 = 12345
  currencyCode: text('currency_code').notNull().default('EUR'),
  // ... audit fields
});
```

**Never use**:

```typescript
// WRONG: Do not use decimal/numeric/float for money
amount: decimal('amount', { precision: 10, scale: 2 }),  // ❌ Floating-point issues
```

### Enums (Constitutional: No Magic Strings)

```typescript
import { pgEnum } from 'drizzle-orm/pg-core';

// Define enum type
export const transactionTypeEnum = pgEnum('transaction_type', [
  'income',
  'expense',
  'transfer',
]);

// Use in schema
export const transactions = pgTable('transactions', {
  type: transactionTypeEnum('type').notNull(),
  // ...
});
```

### Relationships (Foreign Keys)

```typescript
export const accounts = pgTable('accounts', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  // ...
});

export const transactions = pgTable('transactions', {
  id: serial('id').primaryKey(),
  accountId: integer('account_id')
    .notNull()
    .references(() => accounts.id, { onDelete: 'cascade' }), // Safe cascade
  // ...
});
```

**When to cascade**:

- `onDelete: 'cascade'`: When child records should be deleted with parent (e.g., transaction categories with transactions)
- `onDelete: 'restrict'`: When deletion should be prevented if references exist (e.g., cannot delete account with transactions)
- Constitutional guidance: "cascade on delete only when semantically safe"

### Timestamps (ISO 8601 UTC)

```typescript
// CORRECT: Use timestamp with time zone
transactionDate: timestamp('transaction_date', {
  withTimezone: true,
  mode: 'date'
}).notNull(),
```

**Never use**:

```typescript
// WRONG: Do not use timestamp without time zone
transactionDate: timestamp('transaction_date').notNull(),  // ❌ Loses timezone info
```

---

## Query Patterns

### Example: Query with Drizzle

```typescript
// /server/trpc/routers/health.ts
import { db } from '@/server/db';
import { systemHealth } from '@/server/db/schema';
import { desc, eq } from 'drizzle-orm';

// Get latest health check (active records only)
const latestHealth = await db
  .select()
  .from(systemHealth)
  .where(eq(systemHealth.archived, false))
  .orderBy(desc(systemHealth.checkedAt))
  .limit(1);

// Insert new health check
const newHealth = await db
  .insert(systemHealth)
  .values({
    status: 'healthy',
    message: 'Database connection successful',
    checkedAt: new Date(),
  })
  .returning(); // Returns inserted row with generated ID
```

### Example: Transaction Pattern

```typescript
// Multi-step operation with transaction
await db.transaction(async (tx) => {
  // Step 1: Insert health record
  const [health] = await tx
    .insert(systemHealth)
    .values({ status: 'checking' })
    .returning();

  // Step 2: Update status after check
  await tx
    .update(systemHealth)
    .set({ status: 'healthy', message: 'All checks passed' })
    .where(eq(systemHealth.id, health.id));

  // If any step throws, entire transaction rolls back
});
```

---

## Type Safety Examples

### Inferred Types

```typescript
// Type inferred from schema
type SystemHealth = typeof systemHealth.$inferSelect;
// {
//   id: number;
//   status: string;
//   message: string | null;
//   checkedAt: Date;
//   archived: boolean;
//   createdAt: Date;
//   updatedAt: Date;
// }

type NewSystemHealth = typeof systemHealth.$inferInsert;
// {
//   id?: number;  // Optional (auto-generated)
//   status: string;
//   message?: string | null;
//   checkedAt?: Date;  // Optional (has default)
//   archived?: boolean;  // Optional (has default)
//   createdAt?: Date;  // Optional (has default)
//   updatedAt?: Date;  // Optional (has default)
// }
```

### Type-Safe Queries

```typescript
// TypeScript knows the shape of the result
const results = await db.select().from(systemHealth);
// results: SystemHealth[]

// Autocomplete works on field names
const filtered = await db
  .select()
  .from(systemHealth)
  .where(eq(systemHealth.status, 'healthy')); // ✅ TypeScript validates field exists

// Compile error if field doesn't exist
const invalid = await db
  .select()
  .from(systemHealth)
  .where(eq(systemHealth.nonExistent, 'value')); // ❌ Type error
```

---

## Testing Strategy

### Unit Tests (Example)

```typescript
// tests/unit/server/db/schema.test.ts
import { systemHealth } from '@/server/db/schema';

describe('systemHealth schema', () => {
  it('should have required Constitutional audit fields', () => {
    const columns = Object.keys(systemHealth);
    expect(columns).toContain('createdAt');
    expect(columns).toContain('updatedAt');
  });

  it('should have soft delete field', () => {
    const columns = Object.keys(systemHealth);
    expect(columns).toContain('archived');
  });
});
```

### Integration Tests (Example)

```typescript
// tests/integration/server/db/health.test.ts
import { db } from '@/server/db';
import { systemHealth } from '@/server/db/schema';

describe('systemHealth database operations', () => {
  it('should insert and retrieve health record', async () => {
    const [inserted] = await db
      .insert(systemHealth)
      .values({ status: 'test' })
      .returning();

    expect(inserted.status).toBe('test');
    expect(inserted.createdAt).toBeInstanceOf(Date);
    expect(inserted.archived).toBe(false);
  });
});
```

---

## Performance Considerations

### Connection Pooling

Configured in `/server/db/index.ts`:

```typescript
import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
  min: 5, // Minimum connections in pool
  max: 20, // Maximum connections in pool
  idleTimeoutMillis: 30000, // 30 seconds
  connectionTimeoutMillis: 10000, // 10 seconds
});

export const db = drizzle(pool);
```

### Query Optimization

- ✅ Indexes on frequently queried columns
- ✅ Partial indexes for filtered queries (`WHERE archived = false`)
- ✅ Use `LIMIT` for pagination (avoid loading entire tables)
- ✅ Use `.prepare()` for frequently executed queries (future optimization)

---

## Summary

The Foundation Phase data model provides:

- ✅ Example schema demonstrating Constitutional compliance
- ✅ Audit fields (`created_at`, `updated_at`) on all tables
- ✅ Soft delete pattern (`archived` boolean)
- ✅ Type-safe database access via Drizzle ORM
- ✅ Migration strategy with Drizzle Kit
- ✅ Patterns for future entity design

**Next Phase**: Production entities will be designed in Master Data phase (accounts, categories, payees, tags, etc.)
